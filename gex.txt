--!native

-- types
type Leaf = {
	type: string,
	value: string,
	quantity: string,
	range: {number}?,
}

type Tree = {
	name: string,
	childrens: { Tree | Leaf },
	quantity: string?,
	range: {number}?,
	branch: (self: Tree, name: string?) -> Tree,
	leaf: (self: Tree, type: string?, value: string, quanity: string?) -> Leaf,
	add: (self: Tree, leaf: Leaf) -> Tree,
	get: (self: Tree, index: number) -> Leaf | Tree,
	remove: (self: Tree, index: number) -> (Leaf | Tree)?,
	current: (self: Tree) -> number,
	pretty: (self: Tree) -> string
}

type DealMeta = {
	found: boolean,
	windex: number,
}

-- tools
local _quantityDeals: {[string]: (case: Leaf | Tree, text: string, index: number) -> DealMeta}
local _dealWithCase: (case: Leaf | Tree, text: string, index: number) -> DealMeta

local function _booleanToNumber(bool: boolean): number
	return bool and 1 or 0
end

local function _isLeaf(value: Leaf | Tree): boolean
	return value.type ~= nil
end

local function _isCharPosixTest(char: string, posixRegex: string): boolean
	return char:match(posixRegex) ~= nil
end

local _leafDeals: {[string]: (leaf: Leaf, text: string, index: number) -> DealMeta} = {
	["LITERAL"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = leaf.value == text:sub(index, index),
			windex = 1,
		}
	end,
	["ALPHANUMERIC"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = _isCharPosixTest(text:sub(index, index), "%w"),
			windex = 1,
		}
	end,
	["DIGIT"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = _isCharPosixTest(text:sub(index, index), "%d"),
			windex = 1,
		}
	end,
	["ALPHABETIC"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = _isCharPosixTest(text:sub(index, index), "%a"),
			windex = 1,
		}
	end,
	["WILDCARD"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = true,
			windex = 1,
		}
	end,
	["LINE_START"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = _isCharPosixTest(text, "^"),
			windex = _booleanToNumber(_isCharPosixTest(text, "^")),
		}
	end,
	["LINE_END"] = function(leaf: Leaf, text: string, index: number): DealMeta
		return {
			found = _isCharPosixTest(text, "$"),
			windex = 0,
		}
	end,
}

local function _dealWithSequence(tree: Tree, text: string, index: number): DealMeta
	local windex = 0
	for _, case: Leaf | Tree in tree.childrens do
		local deal: DealMeta = _quantityDeals[case.quantity](case, text, index + windex)
		if deal.found then
			return deal
		end
	end
	return {
		found = false,
		windex = 0,
	}
end

local function _dealWithGroup(tree: Tree, text: string, index: number): DealMeta
	local windex = 0
	for _, case: Leaf | Tree in tree.childrens do
		local deal: DealMeta = _quantityDeals[case.quantity](case, text, index + windex)
		windex += deal.windex
		if not deal.found then
			return {
				found = false,
				windex = 0
			}
		end
	end
	return {
		found = true,
		windex = windex,
	}
end

local function _dealWithAlternative(tree: Tree, text: string, index: number): DealMeta
	for _, case: Leaf | Tree in tree.childrens do
		local deal: DealMeta = _quantityDeals[case.quantity](case, text, index)
		if deal.found then
			return deal
		end
	end
	return {
		found = false,
		windex = 0,
	}
end

_dealWithCase = function(case: Leaf | Tree, text: string, index: number): DealMeta
	if _isLeaf(case) then
		local leaf = (case :: Leaf)
		local deal = _leafDeals[leaf.type]
		if deal then
			return deal(leaf, text, index)
		end
	else
		local tree = (case :: Tree)
		if tree.name == "GROUP_START" then
			return _dealWithGroup(tree, text, index)
		elseif tree.name == "SEQUENCE_START" then
			return _dealWithSequence(tree, text, index)
		elseif tree.name == "ALTERNATIVE" then
			return _dealWithAlternative(tree, text, index)
		end
	end
	return {
		found = false,
		windex = 0
	}
end

_quantityDeals = {
	["EXACT"] = function(case: Leaf | Tree, text: string, index: number): DealMeta
		return _dealWithCase(case, text, index)
	end,
	["ONE_AND_MORE"] = function(case: Leaf | Tree, text: string, index: number): DealMeta
		local windex = 0
		local deal: DealMeta = _dealWithCase(case, text, index)
		if not deal.found then
			return deal
		else
			local txtLen = text:len()
			while deal.found do
				windex += deal.windex
				if index + windex > txtLen then
					break
				end
				deal = _dealWithCase(case, text, index + windex)
			end
		end
		return {
			found = true,
			windex = windex
		}
	end,
	["ZERO_OR_MORE"] = function(case: Leaf | Tree, text: string, index: number): DealMeta
		local deal = _quantityDeals["ONE_AND_MORE"](case, text, index)
		deal.found = true
		return deal
	end,
	["ZERO_OR_ONE"] = function(case: Leaf | Tree, text: string, index: number): DealMeta
		local deal: DealMeta = _dealWithCase(case, text, index)
		if not deal.found then
			return {
				found = true,
				windex = 0
			}
		end
		return deal
	end,
	["RANGE"] = function(case: Leaf | Tree, text: string, index: number): DealMeta
		local windex = 0
		local counter = 0
		local found = false
		local min = case.range[1]
		local max = case.range[2]
		local txtLen = text:len()
		
		local deal: DealMeta = _dealWithCase(case, text, index)
		while deal.found and counter + 1 <= max do
			windex += deal.windex
			if index + windex > txtLen then
				break
			end
			counter += 1
			deal = _dealWithCase(case, text, index)
		end
		found = counter >= min and counter <= max
		
		return {
			found = found,
			windex = windex
		}
	end,
}


-- match
local function _match(regex: Tree, text: string)
	local strlen: number = text:len()
	local windex: number = 1	
	local rindex: number = 1
	local rulesc: number = regex:current()
	local case: Leaf | Tree
	local found = true
	local finished = false
	
	local function work()
		case = regex.childrens[rindex]
		if case then
			local dealMeta: DealMeta = _quantityDeals[case.quantity](case, text, windex)
			if not dealMeta.found or dealMeta.windex == 0 or strlen <= 0 then
				found = false
				return
			end
		end
		
		while windex <= strlen do
			case = regex.childrens[rindex]
			if case then
				local dealMeta: DealMeta = _quantityDeals[case.quantity](case, text, windex)
				if not dealMeta.found then
					found = false
					finished = true
					break
				end

				rindex += 1
				windex += dealMeta.windex
				if rindex > rulesc then
					rindex -= 1
					finished = true
					break
				end
			else
				finished = true
				break
			end
			finished = true
		end
	end
	
	work()
	
	local endString = windex - 1
	local startString = 1
	
	-- (RULE_INDEX - 1) == RULES_COUNT check need to be sure that all rules was detected otherwise if text will be too short it may give wrong result
	local found = found and rindex == rulesc
	
	return found, startString, endString
end

-- search
local function _search(regex: Tree, text: string)
	
end

-- regex compiler
local _predefinedTokens = {
	["\\"] = {type = "ESCAPE_CHARACTER", branch = false},
	["|"] = {type = "ALTERNATIVE", branch = false},
	
	["("] = {type = "GROUP_START", branch = true},
	[")"] = {type = "GROUP_END", branch = false},
	
	["["] = {type = "SEQUENCE_START", branch = true},
	["]"] = {type = "SEQUENCE_END", branch = false},
}

local _quantities = {
	["?"] = "ZERO_OR_ONE",
	["*"] = "ZERO_OR_MORE",
	["+"] = "ONE_AND_MORE",
}

local _specialSymbols = {
	["."] = "WILDCARD",
	["w"] = "ALPHANUMERIC",
	["d"] = "DIGIT",
	["a"] = "ALPHABETIC",
	["x"] = "HEXADECIMAL",
	["^"] = "LINE_START",
	["$"] = "LINE_END",
}

local function _new_tree(name: string): Tree
	return {
		name = name or "root",
		quantity = "EXACT",
		childrens = {},
		
		branch = function(self: Tree, name: string?): Tree
			local branch = _new_tree(name or "branch")
			table.insert(self.childrens, branch)
			return branch
		end,
		
		leaf = function(self: Tree, type: string?, value: string, quantity: string?): Leaf
			local leaf = { type = type or "unknown", value = value, quantity = quantity or "EXACT" }
			table.insert(self.childrens, leaf)
			return leaf
		end,
		
		add = function(self: Tree, leaf: Leaf): Tree
			table.insert(self.childrens, leaf)
			return self
		end,
		
		get = function(self: Tree, index: number): Leaf | Tree
			return self.childrens[index]
		end,
		
		remove = function(self: Tree, index: number): (Leaf | Tree)?
			return table.remove(self.childrens, index)
		end,
		
		current = function(self: Tree): number
			return #self.childrens
		end,
		
		pretty = function(self: Tree)
			local quantityToStr = function(value: Leaf | Tree)
				return value.quantity == "RANGE" and ("%s(%i, %i)"):format(value.quantity, value.range[1], value.range[2]) or ("(%s)"):format(value.quantity)
			end
			
			local function f(childrens: {Tree | Leaf}, space: string)
				local innerbuffer = ""
				for _, value: Tree | Leaf in childrens do
					if _isLeaf(value) then
						innerbuffer ..= ("%s%s %s %s\n"):format(space, value.type, value.value, quantityToStr(value))
					else
						innerbuffer ..= ("%s%s %s:\n%s"):format(space, value.name, quantityToStr(value), f(value.childrens, space .. space))
					end
				end
				return innerbuffer
			end
			
			return self.name .. ":\n" .. f(self.childrens, "\t")
		end,
	}
end

local function _new_lexer(regex: string)
	local size = regex:len()
	local index = 1
	return {
		char = function(): string
			return regex:sub(index, index)
		end,
		test = function(offset: number): string
			return regex:sub(index + offset, index + offset)
		end,
		index = function(): number
			return index
		end,
		next = function(): string
			index += 1
			return regex:sub(index, index)
		end,
		eof = function(): boolean
			return index > size
		end,
	}
end

local function _compile_regex(regex: string): Tree
	local lexer = _new_lexer(regex)
	local root = _new_tree("root")
	
	local _skipWhitespaces
	local _collect_number
	local _parse_range
	local _parse_group
	local _parse
	local _setQuantity
	
	_skipWhitespaces = function()
		local c = lexer.char()
		while _isCharPosixTest(c, "%s+") do
			c = lexer.next()
		end
	end
	
	_collect_number = function(): number
		local b = ""
		local c = lexer.char()
		while _isCharPosixTest(c, "%d") do
			b ..= c
			c = lexer.next()
		end
		return tonumber(b)
	end
	
	_parse_range = function(): {number}
		local a, b, s, m = nil, -1, false, false
		
		lexer.next()
		local c = lexer.next()
		
		while c ~= "}" do
			if _isCharPosixTest(c, "%d") then
				local n = _collect_number()
				if not s then
					a = n
					s = not s
				else
					b = n
				end
				c = lexer.char()
			elseif c == "," then
				m = true
				c = lexer.next()
				_skipWhitespaces()
				c = lexer.char()
			else
				local errorCode = ("Expected comma: r/%s/"):format(regex)
				local errorCodeLen = errorCode:len() + 1
				local index = lexer.index()
				local arrow = string.rep(" ", errorCodeLen - index) .. "^"
				
				error(("\n%s\n%s"):format(errorCode, arrow))
			end
		end
		
		return {a, ((s and m and b == -1) and math.huge or math.max(a, b))}
	end
	
	_setQuantity = function(value: Leaf | Tree)
		local charAfter: string = lexer.test(1)
		local quantity = _quantities[charAfter]
		if quantity then
			value.quantity = quantity
			lexer.next()
		elseif charAfter == "{" then
			value.quantity = "RANGE"
			value.range = _parse_range()
		end
	end
	
	_parse_group = function(branch: Tree, untilChar: string)
		while not lexer.eof() do
			local char = lexer.char()
			if char == untilChar then
				break
			end
			_parse(branch, char)
			lexer.next()
		end
	end
	
	_parse = function(branch: Tree, char: string)
		local predefined = _predefinedTokens[char]
		if predefined then
			if predefined.branch then
				lexer.next()
				local branch = branch:branch(predefined.type)
				if char == '(' then
					_parse_group(branch, ')')
				elseif char == '[' then
					_parse_group(branch, ']')
				end
				_setQuantity(branch)
			else
				if char == "\\" and _quantities[lexer.test(1)] then
					char = lexer.next()
					_setQuantity(branch:leaf("LITERAL", char))
				elseif char == "\\" then
					lexer.next()
					_setQuantity(branch:leaf(_specialSymbols[lexer.char()], lexer.char()))
				elseif char == "|" then
					local left: Leaf = branch:remove(branch:current())
					_parse(branch, lexer.next())
					local right: Leaf = branch:remove(branch:current())
					branch:branch("ALTERNATIVE")
						:add(left)
						:add(right)
				else
					_setQuantity(branch:leaf(predefined.type, char))
				end
			end
		else
			_setQuantity(branch:leaf("LITERAL", char))
		end
	end
	
	while not lexer.eof() do
		local char = lexer.char()
		_parse(root, char)
		lexer.next()
	end
	
	return root
end

local function _check_experimental(tree: Tree, regex: string): Tree
	local experimentals = {
		"LINE_START", "LINE_END"
	}
	local found = {}
	
	local function check(t: Tree)
		for i,v in t.childrens do
			if not _isLeaf(v) then
				check(v)
				continue
			end
			if table.find(experimentals, v.type) ~= nil then
				table.insert(found, v)
			end
		end
	end
	check(tree)
	
	if #found > 0 then
		local warning = ("Found experimental features in r/%s/ they may not work properly\n"):format(regex)
		for i,v in found do
			warning ..= ("\t\t- %s(%s)\n"):format(v.value, v.type)
		end
		if script:GetAttribute("useExperimental") then
			warn(warning)
		else
			warning ..= ("turn on `useExperimental` in `%s` module to suppress error"):format(script:GetFullName())
			error(warning)
		end
	end
	
	return tree
end

-- gex
local gex = {}

function gex.compile(regex: string): typeof(gex)
	return setmetatable({_regex = _check_experimental(_compile_regex(regex), regex)}, {
		__index = gex,
		__tostring = function(self)
			return self._regex:pretty()
		end,
	})
end

function gex:find(text: string, init: number?, multiple: boolean?)
	text = text:sub(init or 1, -1)
	
	if multiple then
		local list = {}
		local found, a, b = true, -1, -1
		local offset = 0
		
		while text:len() > 0 do
			found, a, b = _match(self._regex, text)
			if found then
				table.insert(list, { value = text:sub(a, b), start = offset + a, finish = offset + b })
				text = text:sub(b + 1, -1)
				offset += b
			else
				text = text:sub(2, -1)
				offset += 1
			end
		end

		return list
	else
		return self:match(text)
	end
end

function gex:match(text: string, init: number?)
	return _match(self._regex, text:sub(init or 1, -1))
end

function gex:search(text: string, init: number?)
	return _search(self._regex, text:sub(init or 1, -1))
end

return gex
